[
["index.html", "Introdução ao R 1 Introdução", " Introdução ao R Alexandre Freitas 2020-09-08 1 Introdução Este é um curso voltado para ensinar um pouco de R para os meus amigos =). Este curso foi produzido baseado em materiais de outros cursos, tais como: http://material.curso-r.com/rbase/ https://r4ds.had.co.nz/ Curso de R - Fernando Meireles e Lucas Gelape "],
["o-que-é-o-r.html", "2 O que é o R? 2.1 Como baixar o R?", " 2 O que é o R? R é uma linguagem de programação voltada para a manipulação, análise e visualização de dados. Essa linguagem foi criado originalmente por Ross Ihaka e por Robert Gentleman no departamento de Estatística da Universidade de Auckland, Nova Zelândia. Inclusive o nome ‘R’ advém das iniciais de Ross e Robert. Para saber mais sobre história do R você pode abrir aqui https://cran.r-project.org/doc/html/interface98-paper/paper_2.html. Figure 2.1: Ross Ihaka Figure 2.2: Robert Clifford 2.1 Como baixar o R? Para baixar o R você deve ir no site do CRAN (https://cran.r-project.org/) e baixar a versão mais atualizada do R. Para facilitar a utilização da linguagem utilizamos também uma “integrated development environment (IDE)” chamada RStudio. Ela é a melhor ferramenta que inclui “console, syntax-highlighting editor that supports direct code execution, as well as tools for plotting, history, debugging and workspace management”. Você pode baixar o RStúdio neste link: https://rstudio.com/products/rstudio/. Atenção: baixe o RStudio Desktop. Quaisquer dúvidas, vocês podem seguir o passo a passo deste link http://material.curso-r.com/instalacao/. "],
["interface-do-rstudio-e-primeiros-manuseios.html", "3 Interface do RStudio e primeiros manuseios 3.1 Entendendo o RStudio: 3.2 Operadores e funções matemáticas 3.3 Operadores lógicos 3.4 Tipos e classes de objetos", " 3 Interface do RStudio e primeiros manuseios Neste início de aula começaremos conhecendo um pouco da interface do RStúdio e daremos nossos primeiros comandos no R para começarmos a nos adaptar. 3.1 Entendendo o RStudio: Figure 3.1: RStudio Editor/Scripts: é o lugar em que escrevemos nossos códigos. Console: é o lugar em que os códigos são compilados e recebemos o resultado, avisos e erros. Environment: painel com todos os objetos criados na sessão. History: painel com um histórico dos comandos compilados. Files: mostra os arquivos do diretório Plots: Lugar em que os gráficos serão apresentados. Help: janela onde a documentação das funções serão apresentadas. Caso o seu RStudio não esteja aparecendo a parte de script, é só ir em ‘File &gt; New File &gt; R Script’. Principais atalhos utilizados. Vocês ainda não sabem o que eles fazem, mas eles serão muito úteis daqui para frente. CTRL + ENTER: compila a linha selecionada no script. ALT + - : Cria um (&lt;-) sinal de atribuição. CTRL + SHIFT + M: Cria o (%&gt;%) operador pipe O símbolo ‘#’ Comenta o texto, tudo que vier depois será entendido enquanto um comentário, e não enquanto um código. 3.1.1 Personalizando o RStudio Para nos sentirmos mais confortáveis com o R, o primeiro passo será escolher a aparência que mais nos agrada. Para tanto peço que entrem em ‘Tools &gt; Global Options &gt; Appearence’ e escolham o tema que vocês se sentirem mais à vontade. Eu pessoalmente uso do ‘Pastel on Dark’ porque gosto do fundo preto e dos tons pasteis, mas eu sempre vario nos temas durantes as semanas para não me entediar. 3.2 Operadores e funções matemáticas A grande diferença de se utilizar uma linguagem de programação para softwares como o Excel é que, ao invés de utilizarmos a parte gráfica e ficarmos clicando nos botões para que eles façam as ações por nós, temos que escrever de fato o que queremos que o computador faça. Neste sentido, cada comando que digitamos é para pedir que o ‘computador, faça isto’. 3.2.1 Funções matemáticas básicas O primeiro passo será nos acostumarmos com o R será aprendendo algumas funções matemáticas. Para isso digite as expressões matemáticas abaixo e dê CTRL + ENTER para compilar o código. Você vai perceber que [1] aparece do lado de seu resultado. Isso é para o R te falar que ele está apresentando o primeiro resultado. 1 + 1 ## [1] 2 2 * 2 ## [1] 4 5 / 3 ## [1] 1.666667 4 ^ 2 # Potência ## [1] 16 11 %% 3 # Resto da divisão. ## [1] 2 5 * (4 + 2) - (50/32)^4 # Uso de parênteses ## [1] 24.03954 Parenteses podem ser utilizados, contudo as chaves ‘{}’ e os colchetes ‘[]’ têm outras funções no R. Por isso ao tentarmos utilizá-los temos uma mensagem de erro. Ao lermos a mensagem de error podemos perceber em que lugar da função tivemos o problema e o que causou este problema: (3 + 5) * {4 * [3 * (2 + 1)]} ## Error: &lt;text&gt;:1:16: unexpected &#39;[&#39; ## 1: (3 + 5) * {4 * [ ## ^ Funções matemáticas básicas sqrt(9) # Raiz Quadrada ## [1] 3 abs(-10) # Módulo ou valor absoluto ## [1] 10 log(10) # Logaritmo natural ou neperiano ## [1] 2.302585 log(10, base = 10) # Logaritmo base 10 ## [1] 1 log10(10) # Também logaritmo de base 10 ## [1] 1 exp(1) # Exponencial ## [1] 2.718282 round(4.3323, digits = 2) # Arredondamento ## [1] 4.33 factorial(4) # Fatorial ## [1] 24 Exercicio 1. Mágica com números: Para nos acostumarmos à interface básica do R, tentem fazer este simples teste. Caso execute corretamente você deve terminar com o mesmo número que começou: Escolha qualquer número e adicione 2 à ele. Multiplique o resultado por 3. Subtraia 6. Divida o resultado por 3. 3.3 Operadores lógicos Todos os resultados retornam um resultado lógico (boolena), TRUE or FALSE. Figure 3.2: Operadores lógicos Imagem tirada de http://electionsbr.com/livro/introducao-ao-r.html Exemplos de uso: &quot;a&quot; == &quot;a&quot; ## [1] TRUE 2 &gt; 3 ## [1] FALSE (3 + 4) != 7 ## [1] FALSE Digitem estes códigos no console do R. Antes de compilarem os dados, pensem qual deve ser o resultado. 3 &gt; 5 3 != 4 (3 + 3) != 7 alexandre &lt;- 27 beatriz &lt;- 22 joao_vitor &lt;- 27 evandro &lt;- 65 arthur &lt;- 25 (alexandre | beatriz) &gt; evandro (alexandre + beatriz + joao_vitor) &gt; evandro alexandre &gt;= joao_vitor alexandre == beatriz joao_vitor != arthur 3.4 Tipos e classes de objetos O R possui algumas classes básicas: Integer - Números inteiros Numeric - Números reais Character - Palavras ou frases Factor - Variável categórica de classificação Lógical - TRUE or FALSE Para saber a classe de um objeto você pode usar a função class() numeric &lt;- 1 character &lt;- &quot;a&quot; logical &lt;- FALSE class(numeric) ## [1] &quot;numeric&quot; class(character) ## [1] &quot;character&quot; class(logical) ## [1] &quot;logical&quot; No R trabalhamos com alguns tipos de objetos: vetores, matrizezs, listas, data frames (tabelas) que possuem seus próprios atributos. Esses atributos definem o contexto para a execução de um comando e seu respectivo resultado. 3.4.1 Vetores Vetores são o tipo mais básico do R. Ele permite armazenar um conjunto de elementos da mesma classe. Para criar um vetor é necessário concatenar os valores. Para isso utilizamos a função c(). # Um vetor numérico vector_1 &lt;- c(1, 2, 3) vector_1 ## [1] 1 2 3 # Vetor numérico com valores de 1 a 10 vector_2 &lt;- c(1:10) vector_2 ## [1] 1 2 3 4 5 6 7 8 9 10 # É possível acessar um valor específico dentro do vetor a partir do uso de [] vector_2[3] # Acessando o 3 valor do conjunto ## [1] 3 vector_2[4:7] # É possível acessar mais de um valor ## [1] 4 5 6 7 Outras funções matemáticas: sum() Soma mean() Média median() Mediana sd() Desvio padrão var() Variância cor() Correlação entre dois vetores min() Valor mínimo max() Valor máximo range() Mínimo e o máximo summary() Retorna um sumário dos dados quantile() Retorna os quantis do conjunto numérico Vamos agora refletir um pouco: Caso eu crie um vetor com a seguinte formatação: c(1, “2”, 3), o que acontece? Como podemos ver, quando colocamos classes diferentes dentro de um mesmo vetor, o R muda a classe dos valores. A ordem de dominância é: character &gt; numeric &gt; integer &gt; logical É possível também mudar a classe das variáveis a partir das funções: as.numeric(), as.integer(), as.character() e as.factor() candidatos_eleitos &lt;- c(&quot;Eleito&quot;, &quot;Não eleito&quot;, &quot;Não eleito&quot;, &quot;Não eleito&quot;, &quot;Não eleito&quot;, &quot;Eleito&quot;) class(candidatos_eleitos) ## [1] &quot;character&quot; as.factor(candidatos_eleitos) ## [1] Eleito Não eleito Não eleito Não eleito Não eleito Eleito ## Levels: Eleito Não eleito class(candidatos_eleitos) ## [1] &quot;character&quot; Por que nosso objeto não mudou de classe se compilamos a função as.factor? Para que você altere um objeto você deve sobrescrevê-lo candidatos_eleitos &lt;- as.factor(candidatos_eleitos) class(candidatos_eleitos) ## [1] &quot;factor&quot; ## A função levels() retorna os rótulos do fator levels(candidatos_eleitos) ## [1] &quot;Eleito&quot; &quot;Não eleito&quot; A ordem dos fatores muitas vezes importa, para tanto sugiro que vocês pesquisem mais sobre o pacote forcats. Um exemplo de um gráfico construído que não teve reorganização das ordens dos fatores: Pesquisa de avaliação do Governo Bolsonaro, por faixas de renda,contratada pelo Jota. Mais informações da pesquisa aqui. Figure 3.3: Pesquisa de avaliação do Governo Bolsonaro, por faixas de renda Como podemos ver, a ordem das faixas de renda está: Até 2sm, Mais de 5sm, Mais de 2 até 5 sm, NS/NR. As faixas de renda não estão organizadas de forma crescente ou decrescente, elas estão misturadas. Isso gera um dificultador para a análise do gráfico, podendo inclusive gerar análises erradas para um leitor mais desatento. 3.4.2 Listas e arrays Não vou adentrar em listas e arrays por causa do tempo. 3.4.3 Data.frames (Tabelas) Data.frames são tabelas de dados, o equivalente às nossas conhecidas tabelas do excel. No data-frame cada linha representa uma observação e cada coluna representa uma variável, e todas as observações da mesma variável possuem a mesma classe de objeto. A seguir um exemplo de tabela: data(&quot;USArrests&quot;) # Ler banco de dados de crimes violentos por estado dos EUA head(USArrests) # Visualizar as 6 primeiras observações do banco de dados ## Murder Assault UrbanPop Rape ## Alabama 13.2 236 58 21.2 ## Alaska 10.0 263 48 44.5 ## Arizona 8.1 294 80 31.0 ## Arkansas 8.8 190 50 19.5 ## California 9.0 276 91 40.6 ## Colorado 7.9 204 78 38.7 O RStudio já vem com diversos bancos de dados que são faceis de serem abertos. Digitem data() que aparecerá a lista dos bancos de dados, caso queiram abrir um deles é só digitar data(“nome do banco de dados”). Para saber a descrição do banco de dados é só digitar help(“nome do banco de dados”). Uma das partes mais fundamentais da análise de dados é conhecer bem o banco de dados que estamos trabalhando, para isso existem algumas funções que facilitam essa análise. str() Apresenta a estrutura interna de um objeto. names() Apresenta o nome das variáveis head() Mostra as 6 primeiras linhas tail() Mostra as 6 últimas linhas Observando a strutura interna de nosso banco de dados com str() podemos ver que o objeto é um ‘data.frame’, o número de observações e de variáveis, e a classe de cada uma das variáveis, além de 10 das observações dentro delas. str(USArrests) ## &#39;data.frame&#39;: 50 obs. of 4 variables: ## $ Murder : num 13.2 10 8.1 8.8 9 7.9 3.3 5.9 15.4 17.4 ... ## $ Assault : int 236 263 294 190 276 204 110 238 335 211 ... ## $ UrbanPop: int 58 48 80 50 91 78 77 72 80 60 ... ## $ Rape : num 21.2 44.5 31 19.5 40.6 38.7 11.1 15.8 31.9 25.8 ... Para saber mais sobre bases de dados, entrem em: http://electionsbr.com/livro/bases.html ## Mão na massa Para aprendermos, nada melhor do que treinar, portanto peço que façam os exercícios que estão neste script: "],
["pacotes-dúvidas-e-documentação.html", "4 Pacotes, dúvidas e documentação 4.1 Como encontrar as respostas às minhas dúvidas? 4.2 Pacotes", " 4 Pacotes, dúvidas e documentação 4.1 Como encontrar as respostas às minhas dúvidas? Aprender uma linguagem de dados não é fácil e temos dúvidas a todo momento e muitas vezes vamos encontrar erros em nossos scripts, ou precisamos utilizar funções que não conhecemos ao certo seu funcionamento. O que fazer neste momento? Help / Documentação do R - help() ou ?nome_da_funcao Google Stack Overflow Amigos Vai utilizar uma função que nunca usou antes? Utilize as funções help() ou ?nome_da_funcao. Ao utilizar este comando vai aparecer na aba help a documentação da função analisada. Na documentação teremos uma descrição da função, a apresentação de seu uso com seu respectivo uso padrão e os argumentos que ela aceita. Observe a documentação usando help(str), help(sum), help(sd). Muitos pacotes mantêm um site com a documentação de suas funções, você pode entrar nestes sites também para compreender o uso das mesmas, como o https://dplyr.tidyverse.org/, https://stringr.tidyverse.org/, entre outros. Aparecer error ao tentar compilar o código. O que fazer? A primeira coisa a se fazer é ler o erro que aparece no console. Ele mostra aonde que o R se deu e o que causou o erro. Neste sentido, antes de procurar no google a resposta, o primeiro passo é parar, ler e pensar. Observar no código aonde o erro aconteceu e refletir um pouco o porquê dele. Isso é importante porque nos força a pensar a lógica por trás da linguagem e nos torna melhores programadores. Pensei, quebrei um pouco a cabeça e ainda não consegui entender o que aconteceu. Isso é normal, diversas vezes não consigo entender o erro, ou pensar numa solução para ele. Mas provavelmente alguém mais já passou pelo mesmo error, e o R possui uma grande comunidade de pessoas que se ajudam. Neste sentido é possível pesquisar o erro em dois lugares: Google Stack Overflow, https://pt.stackoverflow.com/ O Stack Overflow é uma comunidade com perguntas e respostas para programadores. Nele você vai encontrar a maior parte das perguntas e respectivas respostas ao seu problema. Não encontrou o seu erro? Faça uma pergunta no site. Às vezes tive que perguntar e todas as vezes fui respondido rapidamente e meu erro foi resolvido com as soluções propostas. Aproveitem, este é um excelente site. 4.2 Pacotes Uma das melhores partes do R é que ele possui uma grande gama de pacotes desenvolvidos pela comunidade de usuários. Quase a totalidade das funções que precisamos utilizar para a análise de dados já foram desenvolvidas por outras pessoas. Os pacotes são bibliotecas contendo funções e dados que vão facilitar muito nossa vida. Para instalar um pacote basta digitar install.packages(“nome_do_pacote”). Porém para utilizá-lo não basta apenas instalá-lo. Sempre que você iniciar o R e quiser utilizar o pacote você deve ler ele com a função library(nome_do_pacote). Alguns pacotes importantes que utlizaremos: install.pakcages(&quot;data.table&quot;) install.pakcages(&quot;tidyverse&quot;) # Possui os pacotes ggplot, dplyr, readr entre outros install.pakcages(&quot;stringr&quot;) install.pakcages(&quot;openxlsx&quot;) install.pakcages(&quot;PNADcIBGE&quot;) "],
["importação.html", "5 Importação 5.1 CSV 5.2 xlsx 5.3 SPSS", " 5 Importação 5.1 CSV Para lermos um arquivo em csv utilizamos uma função da base do r chamada read.csv() e atribuímos o resultado a um objeto. # Carregando a base de dados de famílias beneficiárias do Programa Bolsa Merenda mg_dados_csv &lt;- read.csv(&quot;/home/xedar/Documents/Trabalho/demanda_clientes/[SEDESE] Dados Educacao/MG_dados.csv&quot;, sep = &quot;;&quot;) 5.2 xlsx Para lermos um arquivo de excel ou xlsx utilizamos o pacote openxlsx e sua função read.xlsx(). # Carregando o pacote openxlsx library(openxlsx) # Carregando a base de dados sobre os municípios de Minas Gerais mg_dados_xlsx &lt;- read.xlsx(&quot;/home/xedar/Documents/Trabalho/demanda_clientes/[SEDESE] Dados Educacao/MG_dados.xlsx&quot;) 5.3 SPSS Alguns softwares possuem seus próprios formatos para armazenamento de arquivos. Um exemplo são arquivos do SPSS “.sav”. Eles podem ser lidos pelo pacote “haven”. # Carregando o pacote haven library(haven) # Carregando uma base de dados &#39;.sav&#39; dados &lt;- read_sav(&quot;nome_da_base&quot;) Para outros tips de importação de dados, sugiro que leiam mais no site: http://electionsbr.com/livro/importacao.html "],
["manipulação.html", "6 Manipulação 6.1 select() 6.2 filter() 6.3 mutate() 6.4 arrange() 6.5 Pipe (%&gt;%) 6.6 summarise() 6.7 group_by()", " 6 Manipulação Conseguimos ler nossas bases de dados, mas precisamos agora aprender a manipulá-la. Para tanto utilizaremos o pacote dplyr. Vocês podem acessar o cheatsheet deste pacote em: https://github.com/rstudio/cheatsheets/raw/master/data-transformation.pdf Aprenderemos agora as principais funções: select() Seleciona variáveis filter() Filtra linhas de acordo com seus valores mutate() Cria novas variáveis ou modifica variáveis existentes. summarise() Reduz multiplos valores por um summário arrange() Muda a ordem das observações Além disso existe a função group_by() que realiza as operações acima a partir de grupos. 6.1 select() Vamos observar como funciona a função select a partir do banco de dados USArrests. Para conhecer como a função select() funciona, o primeiro passo é olhar sua documentação, para isso digite help(select). Observação: eu utilizei todos os comandos com a função head() para que fossem apresentados apenas as 6 primeiras observações. Isso é um puxadinho que eu vou ver se corrijo mais para frente. Usage select(.data, ...) # Ler biblioteca library(dplyr) # Ler db data(&quot;USArrests&quot;) # Ver a estrutura do banco de dados str(USArrests) ## &#39;data.frame&#39;: 50 obs. of 4 variables: ## $ Murder : num 13.2 10 8.1 8.8 9 7.9 3.3 5.9 15.4 17.4 ... ## $ Assault : int 236 263 294 190 276 204 110 238 335 211 ... ## $ UrbanPop: int 58 48 80 50 91 78 77 72 80 60 ... ## $ Rape : num 21.2 44.5 31 19.5 40.6 38.7 11.1 15.8 31.9 25.8 ... # Selecionar variável UrbanPop head(select(USArrests, UrbanPop)) ## UrbanPop ## Alabama 58 ## Alaska 48 ## Arizona 80 ## Arkansas 50 ## California 91 ## Colorado 78 # Selecionar as variáveis Murder, Assault e Rape head(select(USArrests, Murder, Assault, Rape)) ## Murder Assault Rape ## Alabama 13.2 236 21.2 ## Alaska 10.0 263 44.5 ## Arizona 8.1 294 31.0 ## Arkansas 8.8 190 19.5 ## California 9.0 276 40.6 ## Colorado 7.9 204 38.7 # Criar um novo banco de dados com apenas as variáveis Murder e Assault murder_rape_usa &lt;- select(USArrests, Murder, Rape) # Visualizar o banco de dados murder_rape_usa head(murder_rape_usa) ## Murder Rape ## Alabama 13.2 21.2 ## Alaska 10.0 44.5 ## Arizona 8.1 31.0 ## Arkansas 8.8 19.5 ## California 9.0 40.6 ## Colorado 7.9 38.7 # Vamos criar um banco de dados com todas as variáveis menos Rape murder_all_but_rape &lt;- select(USArrests, -Rape) # Visualizar o banco de dados head(murder_all_but_rape) ## Murder Assault UrbanPop ## Alabama 13.2 236 58 ## Alaska 10.0 263 48 ## Arizona 8.1 294 80 ## Arkansas 8.8 190 50 ## California 9.0 276 91 ## Colorado 7.9 204 78 # Para não encher meu environment de dados, vou utilizar a função rm() para limpá-lo rm(murder_rape_usa, murder_all_but_rape) Como podemos ver podemos selecionar quantas variáveis que estão no banco de dados que quisermos. Para falarmos que não queremos uma variável específica podemos colocar ‘-nome_da_variável’. 6.2 filter() Vamos agora aprender a filtrar observações. help(filter) Usage filter(.data, ..., .preserve = FALSE) # Filtrando os Estados com mais de 20 rapes por 100.000 pessoas. head(filter(USArrests, Rape &gt; 20)) ## Murder Assault UrbanPop Rape ## 1 13.2 236 58 21.2 ## 2 10.0 263 48 44.5 ## 3 8.1 294 80 31.0 ## 4 9.0 276 91 40.6 ## 5 7.9 204 78 38.7 ## 6 15.4 335 80 31.9 # Filtrando os Estados com igual ou maior do que 20 rapes por 100.000 pessoas head(filter(USArrests, Rape &gt;= 20)) ## Murder Assault UrbanPop Rape ## 1 13.2 236 58 21.2 ## 2 10.0 263 48 44.5 ## 3 8.1 294 80 31.0 ## 4 9.0 276 91 40.6 ## 5 7.9 204 78 38.7 ## 6 15.4 335 80 31.9 # Com o símbolo &gt;= encontramos 1 estado a mais que não havia sido encontrado da primeira vez # Qual é este Estado? Como fazer para encontrá-lo através do filter()? # Quais são os estados com 20 rapes ou mais e que possuem população urbana igual ou maior a 80%? head(filter(USArrests, Rape &gt; 20 &amp; UrbanPop &gt;= 80)) ## Murder Assault UrbanPop Rape ## 1 8.1 294 80 31.0 ## 2 9.0 276 91 40.6 ## 3 15.4 335 80 31.9 ## 4 5.3 46 83 20.2 ## 5 10.4 249 83 24.0 ## 6 12.2 252 81 46.0 6.3 mutate() Vamos visualizar a função mutate: help(mutate) Create or transform variables Description mutate() adds new variables and preserves existing ones; transmute() adds new variables and drops existing ones. Both functions preserve the number of rows of the input. New variables overwrite existing variables of the same name. Usage mutate(.data, ...) transmute(.data, ...) Vamos ver como funciona: # Os casos de murder, assault e rape estão na taxa de 1:100.000; # Vamos criar novas variáveis com a taxa de 1:10.000? head(mutate(USArrests, murder_10k = Murder * 10, assault_10k = Assault * 10, rape_10k = Rape * 10)) ## Murder Assault UrbanPop Rape murder_10k assault_10k rape_10k ## 1 13.2 236 58 21.2 132 2360 212 ## 2 10.0 263 48 44.5 100 2630 445 ## 3 8.1 294 80 31.0 81 2940 310 ## 4 8.8 190 50 19.5 88 1900 195 ## 5 9.0 276 91 40.6 90 2760 406 ## 6 7.9 204 78 38.7 79 2040 387 # Podemos também alterar colunas existentes head(mutate(USArrests, Murder = Murder * 10, Assault = Assault * 10, Rape = Rape * 10)) ## Murder Assault UrbanPop Rape ## 1 132 2360 58 212 ## 2 100 2630 48 445 ## 3 81 2940 80 310 ## 4 88 1900 50 195 ## 5 90 2760 91 406 ## 6 79 2040 78 387 Cuidado para não sobrescrever seu banco de dados sem que você realmente queira fazer isso. Eu normalmente deixo um banco de dados original e crio uma cópia deste para sobrescrever apenas a cópia. Essa é apenas uma dica, pois não haveria problema no exemplo acima já que não salvamos o resultado no objeto. 6.4 arrange() Vamos observar a documentação da função arrange(): help(arrange) Arrange rows by variables Description Order tbl rows by an expression involving its variables. Usage arrange(.data, ...) ## S3 method for class &#39;grouped_df&#39; arrange(.data, ..., .by_group = FALSE) Arguments .data A tbl. All main verbs are S3 generics and provide methods for tbl_df(), dtplyr::tbl_dt() and dbplyr::tbl_dbi(). ... Comma separated list of unquoted variable names, or expressions involving variable names. Use desc() to sort a variable in descending order. .by_group If TRUE, will sort first by grouping variable. Applies to grouped data frames only. Agora alguns exemplos. Para estes exemplos vamos utilizar os dados que estão na biblioteca gapminder # install.packages(&quot;gapminder&quot;) library(gapminder) # Observar a estrutura str(gapminder) ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 1704 obs. of 6 variables: ## $ country : Factor w/ 142 levels &quot;Afghanistan&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... ## $ continent: Factor w/ 5 levels &quot;Africa&quot;,&quot;Americas&quot;,..: 3 3 3 3 3 3 3 3 3 3 ... ## $ year : int 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ... ## $ lifeExp : num 28.8 30.3 32 34 36.1 ... ## $ pop : int 8425333 9240934 10267083 11537966 13079460 14880372 12881816 13867957 16317921 22227415 ... ## $ gdpPercap: num 779 821 853 836 740 ... # Ordene por país arrange(gapminder, country) ## # A tibble: 1,704 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. ## 2 Afghanistan Asia 1957 30.3 9240934 821. ## 3 Afghanistan Asia 1962 32.0 10267083 853. ## 4 Afghanistan Asia 1967 34.0 11537966 836. ## 5 Afghanistan Asia 1972 36.1 13079460 740. ## 6 Afghanistan Asia 1977 38.4 14880372 786. ## 7 Afghanistan Asia 1982 39.9 12881816 978. ## 8 Afghanistan Asia 1987 40.8 13867957 852. ## 9 Afghanistan Asia 1992 41.7 16317921 649. ## 10 Afghanistan Asia 1997 41.8 22227415 635. ## # … with 1,694 more rows # Ordene a por gdpPercap (de forma descendente) e país (ascendente) arrange(gapminder, -gdpPercap, country) ## # A tibble: 1,704 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Kuwait Asia 1957 58.0 212846 113523. ## 2 Kuwait Asia 1972 67.7 841934 109348. ## 3 Kuwait Asia 1952 55.6 160000 108382. ## 4 Kuwait Asia 1962 60.5 358266 95458. ## 5 Kuwait Asia 1967 64.6 575003 80895. ## 6 Kuwait Asia 1977 69.3 1140357 59265. ## 7 Norway Europe 2007 80.2 4627926 49357. ## 8 Kuwait Asia 2007 77.6 2505559 47307. ## 9 Singapore Asia 2007 80.0 4553009 47143. ## 10 Norway Europe 2002 79.0 4535591 44684. ## # … with 1,694 more rows 6.5 Pipe (%&gt;%) Antes de falarmos das funções summarise e group_by vamos falar do pipe (%&gt;%). Ela faz parte do pacote dplyr do tidyverse. Ela é uma das ferramentas mais utilizadas em nosso código, e ela permite a execução de funções em sequência, etapa por etapa. O pipe deixa nosso código mais limpo e mais fácil de compreensão. Vamos ver alguns usos: library(dplyr) gapminder %&gt;% filter(year == 1952) ## # A tibble: 142 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. ## 2 Albania Europe 1952 55.2 1282697 1601. ## 3 Algeria Africa 1952 43.1 9279525 2449. ## 4 Angola Africa 1952 30.0 4232095 3521. ## 5 Argentina Americas 1952 62.5 17876956 5911. ## 6 Australia Oceania 1952 69.1 8691212 10040. ## 7 Austria Europe 1952 66.8 6927772 6137. ## 8 Bahrain Asia 1952 50.9 120447 9867. ## 9 Bangladesh Asia 1952 37.5 46886859 684. ## 10 Belgium Europe 1952 68 8730405 8343. ## # … with 132 more rows gapminder %&gt;% filter(year == 1952) %&gt;% select(country, pop) ## # A tibble: 142 x 2 ## country pop ## &lt;fct&gt; &lt;int&gt; ## 1 Afghanistan 8425333 ## 2 Albania 1282697 ## 3 Algeria 9279525 ## 4 Angola 4232095 ## 5 Argentina 17876956 ## 6 Australia 8691212 ## 7 Austria 6927772 ## 8 Bahrain 120447 ## 9 Bangladesh 46886859 ## 10 Belgium 8730405 ## # … with 132 more rows gapminder %&gt;% mutate(pib = pop * gdpPercap) %&gt;% arrange(-pib) ## # A tibble: 1,704 x 7 ## country continent year lifeExp pop gdpPercap pib ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 United States Americas 2007 78.2 301139947 42952. 1.29e13 ## 2 United States Americas 2002 77.3 287675526 39097. 1.12e13 ## 3 United States Americas 1997 76.8 272911760 35767. 9.76e12 ## 4 United States Americas 1992 76.1 256894189 32004. 8.22e12 ## 5 United States Americas 1987 75.0 242803533 29884. 7.26e12 ## 6 China Asia 2007 73.0 1318683096 4959. 6.54e12 ## 7 United States Americas 1982 74.6 232187835 25010. 5.81e12 ## 8 United States Americas 1977 73.4 220239000 24073. 5.30e12 ## 9 United States Americas 1972 71.3 209896000 21806. 4.58e12 ## 10 Japan Asia 2007 82.6 127467972 31656. 4.04e12 ## # … with 1,694 more rows gapminder %&gt;% filter(year == 2007) %&gt;% mutate(pib = pop * gdpPercap) %&gt;% arrange(-pib) ## # A tibble: 142 x 7 ## country continent year lifeExp pop gdpPercap pib ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 United States Americas 2007 78.2 301139947 42952. 1.29e13 ## 2 China Asia 2007 73.0 1318683096 4959. 6.54e12 ## 3 Japan Asia 2007 82.6 127467972 31656. 4.04e12 ## 4 India Asia 2007 64.7 1110396331 2452. 2.72e12 ## 5 Germany Europe 2007 79.4 82400996 32170. 2.65e12 ## 6 United Kingdom Europe 2007 79.4 60776238 33203. 2.02e12 ## 7 France Europe 2007 80.7 61083916 30470. 1.86e12 ## 8 Brazil Americas 2007 72.4 190010647 9066. 1.72e12 ## 9 Italy Europe 2007 80.5 58147733 28570. 1.66e12 ## 10 Mexico Americas 2007 76.2 108700891 11978. 1.30e12 ## # … with 132 more rows 6.6 summarise() Vamos observar a documentação da função summarise: help(summarise) Reduce multiple values down to a single value Description Create one or more scalar variables summarizing the variables of an existing tbl. Tbls with groups created by group_by() will result in one row in the output for each group. Tbls with no groups will result in one row. Useful functions Center: mean(), median() Spread: sd(), IQR(), mad() Range: min(), max(), quantile() Position: first(), last(), nth(), Count: n(), n_distinct() Logical: any(), all() Agora alguns exemplos: gapminder %&gt;% filter(year == max(year)) %&gt;% summarise(n_paises_analisados = n(), ano = first(year), mean_gdpPercap = mean(gdpPercap), max_gdpPercap = max(gdpPercap), min_gdp_percap = min(gdpPercap), mean_life_exp = mean(lifeExp), max_life_exp = max(lifeExp), min_life_exp = min(lifeExp)) ## # A tibble: 1 x 8 ## n_paises_analis… ano mean_gdpPercap max_gdpPercap min_gdp_percap ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 142 2007 11680. 49357. 278. ## # … with 3 more variables: mean_life_exp &lt;dbl&gt;, max_life_exp &lt;dbl&gt;, ## # min_life_exp &lt;dbl&gt; gapminder %&gt;% group_by(continent) %&gt;% summarise(n_paises = n_distinct(country)) ## # A tibble: 5 x 2 ## continent n_paises ## &lt;fct&gt; &lt;int&gt; ## 1 Africa 52 ## 2 Americas 25 ## 3 Asia 33 ## 4 Europe 30 ## 5 Oceania 2 6.7 group_by() O que eh Description Most data operations are done on groups defined by variables. group_by() takes an existing tbl and converts it into a grouped tbl where operations are performed &quot;by group&quot;. ungroup() removes grouping. Usage group_by(.data, ..., add = FALSE, .drop = group_by_drop_default(.data)) ungroup(x, ...) Exemplo gapminder %&gt;% filter(year == max(year)) %&gt;% group_by(continent) %&gt;% summarise(mean_gdpPercap = mean(gdpPercap), mean_life_exp = mean(lifeExp)) %&gt;% arrange(-mean_life_exp) ## # A tibble: 5 x 3 ## continent mean_gdpPercap mean_life_exp ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Oceania 29810. 80.7 ## 2 Europe 25054. 77.6 ## 3 Americas 11003. 73.6 ## 4 Asia 12473. 70.7 ## 5 Africa 3089. 54.8 gapminder %&gt;% group_by(year, continent) %&gt;% summarise(mean_gdpPercap = mean(gdpPercap), mean_life_exp = mean(lifeExp)) %&gt;% arrange(-year, -mean_life_exp) ## # A tibble: 60 x 4 ## # Groups: year [12] ## year continent mean_gdpPercap mean_life_exp ## &lt;int&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2007 Oceania 29810. 80.7 ## 2 2007 Europe 25054. 77.6 ## 3 2007 Americas 11003. 73.6 ## 4 2007 Asia 12473. 70.7 ## 5 2007 Africa 3089. 54.8 ## 6 2002 Oceania 26939. 79.7 ## 7 2002 Europe 21712. 76.7 ## 8 2002 Americas 9288. 72.4 ## 9 2002 Asia 10174. 69.2 ## 10 2002 Africa 2599. 53.3 ## # … with 50 more rows "]
]
